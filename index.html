<!DOCTYPE html>
<meta charset="utf-8">

<head>
  <link rel="stylesheet" type="text/css" href="styles.css">
</head>

<!-- Body tag is where we will append our SVG and SVG objects-->
<body>
</body>

<!-- Load in the d3 library -->
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://d3js.org/d3-axis.v1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.18.1/moment.min.js"></script>


<script>

// Load in data by defining a series of promises...
let loadPlayByPlay = function(dataList){
    return new Promise(function(resolve,reject){
        
        d3.csv("http://127.0.0.1:8080/stats.csv").then(function(data) {
            data.forEach(function(d) {
                d["home_score"] = +d["home_score"];
                d["visit_score"] = +d["visit_score"];
                d["score differential"] = +d["score differential"];
                d["time"] = +d["time(seconds)"];
            });
            dataList.push(data.slice(0,140));
            resolve(dataList);
        });

    });
}

let loadBoxScore = function(dataList){
    return new Promise(function(resolve,reject){

        d3.csv("http://127.0.0.1:8080/Box_stats.csv").then(function(data) {
            data.forEach(function(d) {
                d["players"] = d["players"];
            });
            dataList.push(data);
            resolve(dataList);
        });
    });
}

// Complete the promises in sequences and add the results in an array
dataList = []

loadPlayByPlay(dataList).then(function(result){
    return loadBoxScore(result);
}).then(function(result){
    raw_PlayByPlay_data = result[0]
    raw_BoxScore_data = result[1]
    //Finally, pass the data downstream
    postDataLoad(raw_PlayByPlay_data,raw_BoxScore_data)
})


// Now that data is loaded, put it into plot
function postDataLoad(raw_PlayByPlay_data,raw_BoxScore_data) {

console.log("Data loads?");
console.log(raw_PlayByPlay_data[0]);  
console.log(raw_BoxScore_data[0]);  

// Extract time and score differential into arrays
var xdata = raw_PlayByPlay_data.map(d => d["time"]);
var ydata = raw_PlayByPlay_data.map(d => d["score differential"]);
var home = raw_PlayByPlay_data.map(d => d["home"]);
var visit = raw_PlayByPlay_data.map(d => d["visit"])

// Put data into input format for d3.line
var xy = []; 
for(var i = 0; i < xdata.length; i++ ) {
   xy.push({x: xdata[i], y: ydata[i], home:home[i], visit:visit[i]});
}

var baseline_xy = []; 
for(var i = 0; i < xdata.length; i++ ) {
    baseline_xy.push({x: xdata[i], y: 0});
}

// Try to extract per player information
var playerData = [];
var playerDataDict = {}
var currentVisitInfo = "";  
var currentHomeInfo = "";

for(var i = 0; i < raw_BoxScore_data.length; i++ ) {
    currentPlayer = raw_BoxScore_data[i].players.split(" ")[1].toLowerCase()
    playerDataDict[currentPlayer] = {"info": [], "time": [], "y":[]}
    for(var j = 0; j < xdata.length; j++ ) {
        currentInfo = ""
        currentVisitInfo = visit[j].toLowerCase()
        if (currentVisitInfo.includes(currentPlayer))
        {
            currentInfo += currentVisitInfo
        }
        currentInfo += " "
        currentHomeInfo = home[j].toLowerCase()
        if (currentHomeInfo.includes(currentPlayer))
        {
            currentInfo += currentHomeInfo
        }
        if (currentInfo !== " ")
        {
            playerDataDict[currentPlayer]["time"].push(xdata[j])
            playerDataDict[currentPlayer]["y"].push(ydata[j])

            playerDataDict[currentPlayer]["info"].push(home[j] + visit[j])
        }   
    }
}

// Use the margin convention practice 
var margin = {top: 50, right: 50, bottom: 50, left: 50}
  , width = window.innerWidth - margin.left - margin.right // Use the window's width 
  , height = window.innerHeight - margin.top - margin.bottom; // Use the window's height

// X scale 
var xScale = d3.scaleLinear()
    .domain(d3.extent(xy, function(d) {return d.x;})) 
    .range([0, width]);

const xAxis = d3.axisBottom(xScale)
    .tickValues(xy.x)
    .tickFormat(d => moment.utc((15*60-d)*1000).format('mm:ss'))
    .ticks(20)

// Y scale 
var extrema = d3.extent(xy, function(d) {return d.y;})
extrema[0] -= 1
extrema[1] += 1
var yScale = d3.scaleLinear()
    .domain(extrema)
    .range([height, 0]); 
  
// d3's line generator
var line = d3.line()
    .x(function(d) { return xScale(d.x); }) // set the x values for the line generator
    .y(function(d) { return yScale(d.y); }) // set the y values for the line generator 
    .curve(d3.curveStepAfter) // apply smoothing to the line

var baseline = d3.line()
    .x(function(d) { return xScale(d.x); }) // set the x values for the line generator
    .y(function(d) { return yScale(d.y); }) // set the y values for the line generator 
    
// Add the SVG to the page and employ margin rule up above
var svg = d3.select("body")
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

// Call the x axis in a group tag
svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    //.call(d3.axisBottom(xScale)); // Create an axis component with d3.axisBottom
    .call(xAxis)

// Label the x axis
svg.append("text")
    .attr("class", "x label")
    .attr("text-anchor", "end")
    .attr("x", width/2)
    .attr("y", height + 40)
    .text("Time")
    .attr("font","garamond");

// Call the y axis in a group tag
svg.append("g")
    .attr("class", "y axis")
    .call(d3.axisLeft(yScale)); // Create an axis component with d3.axisLeft

// Label the y axis
svg.append("text")
    .attr("class", "y label")
    .attr("text-anchor", "end")
    .attr("y", 6)
    .attr("dy", ".75em")
    .attr("transform", "rotate(-90)")
    .text("Home")
    .attr("font","garamond");

/*
svg.append("text")
    .attr("class", "y label")
    .attr("text-anchor", "end")
    .attr("x", -1*height+45)
    .attr("dy", ".75em")
    .attr("transform", "rotate(-90)")
    .text("Away");
*/

// Append the path, bind the data, and call the line generator

// Add baseline for score differential = 0
svg.append("path")
    .datum(baseline_xy)
    .attr("class", "baseline") 
    .style("stroke-dasharray", ("3, 3")) 
    .attr("d", baseline) 

// Add path for data above the baseline
svg.append("path")
    .datum(xy) // 10. Binds data to the line 
    .attr("d", line)
    .attr("class","line")

// Define the div for the tooltip
var div = d3.select("body").append("div")	
    .attr("class", "tooltip")				
    .style("opacity", 0);

// Restrict dataset to only scoring plays
var pruned_xy = []; 
for(var i = 1; i < xdata.length; i++ ) {
    if (ydata[i] !== ydata[i-1]){
        pruned_xy.push({x: xdata[i], y: ydata[i], home:home[i], visit:visit[i]});
    }
}

// Appends a circle for each datapoint 
svg.selectAll(".dot")
    .data(pruned_xy)
  .enter().append("circle") // Uses the enter().append() method
    .attr("class", "dot") // Assign a class for styling
    .attr("cx", function(d) { return xScale(d.x) })
    .attr("cy", function(d) { return yScale(d.y) })
    .attr("r", 4)
    .on("mouseover", function(d) {		
            div.transition()
                .duration(200)	
                .style("opacity", 1);		
            div.html(d.home + d.visit)
                .style("left", (d3.event.pageX) + "px")		
                .style("top", (d3.event.pageY - 40) + "px");	
            })					
        .on("mouseout", function(d) {		
            div.transition()		
                .duration(500)		
                .style("opacity", 0);	
        });

currentPlayer = "james"
var player_xy = []; 
for(var i = 1; i < playerDataDict[currentPlayer]["time"].length; i++ ) {
    player_xy.push({x: playerDataDict[currentPlayer]["time"][i], y: playerDataDict[currentPlayer]["y"][i], info: playerDataDict[currentPlayer]["info"][i]});
    }

console.log(player_xy)

// Test for player dots
svg.selectAll(".pdot")
    .data(player_xy)
  .enter().append("circle") // Uses the enter().append() method
    .attr("class", "pdot") // Assign a class for styling
    .attr("cx", function(d) { return xScale(d.x) })
    .attr("cy", function(d) { return yScale(d.y) })
    .attr("r", 6)
    .on("mouseover", function(d) {		
            div.transition()
                .duration(200)	
                .style("opacity", 1);		
            div.html(d.info)
                .style("left", (d3.event.pageX) + "px")		
                .style("top", (d3.event.pageY - 40) + "px");	
            })					
        .on("mouseout", function(d) {		
            div.transition()		
                .duration(500)		
                .style("opacity", 0);	
        });
    };


</script>